{{- /*
Copyright Simon Li. All Rights Reserved.
SPDX-License-Identifier: APACHE-2.0
*/}}

{{- if or .Values.dbInit.enabled .Values.dbSync.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "common.names.fullname" . }}-scripts
  namespace: {{ include "common.names.namespace" . | quote }}
  labels: {{- include "common.labels.standard" ( dict "customLabels" .Values.commonLabels "context" $ ) | nindent 4 }}
    app.kubernetes.io/component: auth
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  db-init.sh: |
    #!/bin/bash
    set -e

    MAX_RETRIES={{ .Values.database.connection.maxRetries }}
    RETRY_INTERVAL={{ .Values.database.connection.retryInterval }}

    {{- if eq .Values.database.type "mysql" }}
    # MySQL database initialization
    DB_HOST="{{ include "powerdns-auth.databaseHost" . }}"
    DB_PORT="{{ include "powerdns-auth.databasePort" . }}"
    DB_NAME="{{ include "powerdns-auth.databaseName" . }}"
    DB_ADMIN_USER="${DB_ADMIN_USER:-root}"
    DB_ADMIN_PASS="${DB_ADMIN_PASS}"
    DB_USER="{{ include "powerdns-auth.databaseUsername" . }}"
    DB_PASS="${DB_USER_PASS}"

    MYSQL_ADMIN="mysql -h ${DB_HOST} -P ${DB_PORT} -u ${DB_ADMIN_USER} -p${DB_ADMIN_PASS}"

    echo "Waiting for MySQL connection..."
    attempts=0
    while ! ${MYSQL_ADMIN} -e 'SELECT 1' >/dev/null 2>&1; do
        if [ "${attempts}" -ge "${MAX_RETRIES}" ]; then
            echo "ERROR: Unable to connect to MySQL after ${MAX_RETRIES} attempts"
            exit 1
        fi
        echo "Attempt ${attempts}/${MAX_RETRIES}: Waiting for MySQL..."
        sleep $((attempts * RETRY_INTERVAL / 3 + RETRY_INTERVAL))
        attempts=$((attempts + 1))
    done

    echo "MySQL connection established"

    # Create database if not exists
    echo "Creating database ${DB_NAME} if not exists..."
    ${MYSQL_ADMIN} -e "CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

    # Create user and grant privileges
    echo "Creating user ${DB_USER} if not exists..."
    ${MYSQL_ADMIN} -e "CREATE USER IF NOT EXISTS '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASS}';"
    ${MYSQL_ADMIN} -e "GRANT ALL PRIVILEGES ON \`${DB_NAME}\`.* TO '${DB_USER}'@'%';"
    ${MYSQL_ADMIN} -e "FLUSH PRIVILEGES;"

    echo "MySQL database initialization completed"
    {{- else }}
    # PostgreSQL database initialization
    export PGHOST="{{ include "powerdns-auth.databaseHost" . }}"
    export PGPORT="{{ include "powerdns-auth.databasePort" . }}"
    export PGUSER="${DB_ADMIN_USER:-postgres}"
    export PGPASSWORD="${DB_ADMIN_PASS}"

    DB_NAME="{{ include "powerdns-auth.databaseName" . }}"
    DB_USER="{{ include "powerdns-auth.databaseUsername" . }}"
    DB_PASS="${DB_USER_PASS}"

    echo "Waiting for PostgreSQL connection..."
    attempts=0
    while ! psql -c 'SELECT 1' >/dev/null 2>&1; do
        if [ "${attempts}" -ge "${MAX_RETRIES}" ]; then
            echo "ERROR: Unable to connect to PostgreSQL after ${MAX_RETRIES} attempts"
            exit 1
        fi
        echo "Attempt ${attempts}/${MAX_RETRIES}: Waiting for PostgreSQL..."
        sleep $((attempts * RETRY_INTERVAL / 3 + RETRY_INTERVAL))
        attempts=$((attempts + 1))
    done

    echo "PostgreSQL connection established"

    # Create user if not exists
    echo "Creating user ${DB_USER} if not exists..."
    psql -tc "SELECT 1 FROM pg_roles WHERE rolname='${DB_USER}'" | grep -q 1 || \
        psql -c "CREATE USER ${DB_USER} WITH PASSWORD '${DB_PASS}';"

    # Create database if not exists
    echo "Creating database ${DB_NAME} if not exists..."
    psql -tc "SELECT 1 FROM pg_database WHERE datname='${DB_NAME}'" | grep -q 1 || \
        psql -c "CREATE DATABASE ${DB_NAME} OWNER ${DB_USER};"

    # Grant privileges
    echo "Granting privileges..."
    psql -c "GRANT ALL PRIVILEGES ON DATABASE ${DB_NAME} TO ${DB_USER};"

    echo "PostgreSQL database initialization completed"
    {{- end }}

  db-sync.sh: |
    #!/bin/bash
    set -e

    MAX_RETRIES={{ .Values.database.connection.maxRetries }}
    RETRY_INTERVAL={{ .Values.database.connection.retryInterval }}

    {{- if eq .Values.database.type "mysql" }}
    # MySQL schema synchronization
    DB_HOST="{{ include "powerdns-auth.databaseHost" . }}"
    DB_PORT="{{ include "powerdns-auth.databasePort" . }}"
    DB_NAME="{{ include "powerdns-auth.databaseName" . }}"
    DB_USER="${DB_USER}"
    DB_PASS="${DB_PASSWORD}"

    MYSQL_CMD="mysql -h ${DB_HOST} -P ${DB_PORT} -u ${DB_USER} -p${DB_PASS} ${DB_NAME}"

    echo "Waiting for MySQL connection..."
    attempts=0
    while ! ${MYSQL_CMD} -e 'SELECT 1' >/dev/null 2>&1; do
        if [ "${attempts}" -ge "${MAX_RETRIES}" ]; then
            echo "ERROR: Unable to connect to MySQL after ${MAX_RETRIES} attempts"
            exit 1
        fi
        echo "Attempt ${attempts}/${MAX_RETRIES}: Waiting for MySQL..."
        sleep $((attempts * RETRY_INTERVAL / 3 + RETRY_INTERVAL))
        attempts=$((attempts + 1))
    done

    echo "MySQL connection established"

    # Check if tables exist
    TABLE_COUNT=$(echo "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='${DB_NAME}' AND table_name='domains';" | ${MYSQL_CMD} -N 2>/dev/null || echo "0")

    if [ "${TABLE_COUNT}" -eq "0" ]; then
        echo "Initializing PowerDNS MySQL schema..."

        # Use the schema file from the PowerDNS package if available
        if [ -f "/usr/share/doc/pdns-backend-mysql/schema.mysql.sql" ]; then
            ${MYSQL_CMD} < /usr/share/doc/pdns-backend-mysql/schema.mysql.sql
        else
            # Inline schema for PowerDNS 5.x (idempotent using DROP INDEX IF EXISTS + CREATE INDEX)
            ${MYSQL_CMD} <<'EOSQL'
CREATE TABLE IF NOT EXISTS domains (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255) NOT NULL,
  master                VARCHAR(128) DEFAULT NULL,
  last_check            INT DEFAULT NULL,
  type                  VARCHAR(8) NOT NULL,
  notified_serial       INT UNSIGNED DEFAULT NULL,
  account               VARCHAR(40) CHARACTER SET 'utf8' DEFAULT NULL,
  options               VARCHAR(65535) DEFAULT NULL,
  catalog               VARCHAR(255) DEFAULT NULL,
  PRIMARY KEY (id),
  UNIQUE INDEX name_index (name),
  INDEX catalog_idx (catalog)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS records (
  id                    BIGINT AUTO_INCREMENT,
  domain_id             INT DEFAULT NULL,
  name                  VARCHAR(255) DEFAULT NULL,
  type                  VARCHAR(10) DEFAULT NULL,
  content               VARCHAR(65535) DEFAULT NULL,
  ttl                   INT DEFAULT NULL,
  prio                  INT DEFAULT NULL,
  disabled              TINYINT(1) DEFAULT 0,
  ordername             VARCHAR(255) BINARY DEFAULT NULL,
  auth                  TINYINT(1) DEFAULT 1,
  PRIMARY KEY (id),
  INDEX nametype_index (name, type),
  INDEX domain_id (domain_id),
  INDEX ordername (ordername)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS supermasters (
  ip                    VARCHAR(64) NOT NULL,
  nameserver            VARCHAR(255) NOT NULL,
  account               VARCHAR(40) CHARACTER SET 'utf8' NOT NULL,
  PRIMARY KEY (ip, nameserver)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS comments (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  name                  VARCHAR(255) NOT NULL,
  type                  VARCHAR(10) NOT NULL,
  modified_at           INT NOT NULL,
  account               VARCHAR(40) CHARACTER SET 'utf8' DEFAULT NULL,
  comment               TEXT CHARACTER SET 'utf8' NOT NULL,
  PRIMARY KEY (id),
  INDEX comments_name_type_idx (name, type),
  INDEX comments_order_idx (domain_id, modified_at)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS domainmetadata (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  kind                  VARCHAR(32),
  content               TEXT,
  PRIMARY KEY (id),
  INDEX domainmetadata_idx (domain_id, kind)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS cryptokeys (
  id                    INT AUTO_INCREMENT,
  domain_id             INT NOT NULL,
  flags                 INT NOT NULL,
  active                BOOL,
  published             BOOL DEFAULT 1,
  content               TEXT,
  PRIMARY KEY(id),
  INDEX domainidindex (domain_id)
) Engine=InnoDB CHARACTER SET 'latin1';

CREATE TABLE IF NOT EXISTS tsigkeys (
  id                    INT AUTO_INCREMENT,
  name                  VARCHAR(255),
  algorithm             VARCHAR(50),
  secret                VARCHAR(255),
  PRIMARY KEY (id),
  UNIQUE INDEX namealgoindex (name, algorithm)
) Engine=InnoDB CHARACTER SET 'latin1';
EOSQL
        fi
        echo "MySQL schema initialized successfully"
    else
        echo "MySQL schema already exists, skipping initialization"
    fi
    {{- else }}
    # PostgreSQL schema synchronization
    export PGHOST="{{ include "powerdns-auth.databaseHost" . }}"
    export PGPORT="{{ include "powerdns-auth.databasePort" . }}"
    export PGDATABASE="{{ include "powerdns-auth.databaseName" . }}"
    export PGUSER="${DB_USER}"
    export PGPASSWORD="${DB_PASSWORD}"

    echo "Waiting for PostgreSQL connection..."
    attempts=0
    while ! psql -c 'SELECT 1' >/dev/null 2>&1; do
        if [ "${attempts}" -ge "${MAX_RETRIES}" ]; then
            echo "ERROR: Unable to connect to PostgreSQL after ${MAX_RETRIES} attempts"
            exit 1
        fi
        echo "Attempt ${attempts}/${MAX_RETRIES}: Waiting for PostgreSQL..."
        sleep $((attempts * RETRY_INTERVAL / 3 + RETRY_INTERVAL))
        attempts=$((attempts + 1))
    done

    echo "PostgreSQL connection established"

    # Check if tables exist
    TABLE_COUNT=$(psql -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public' AND table_name='domains';" 2>/dev/null | tr -d ' ' || echo "0")

    if [ "${TABLE_COUNT}" -eq "0" ]; then
        echo "Initializing PowerDNS PostgreSQL schema..."

        # Use the schema file from the PowerDNS package if available
        if [ -f "/usr/share/doc/pdns-backend-pgsql/schema.pgsql.sql" ]; then
            psql < /usr/share/doc/pdns-backend-pgsql/schema.pgsql.sql
        else
            # Inline schema for PowerDNS 5.x (idempotent)
            psql <<'EOSQL'
CREATE TABLE IF NOT EXISTS domains (
  id                    SERIAL PRIMARY KEY,
  name                  VARCHAR(255) NOT NULL,
  master                VARCHAR(128) DEFAULT NULL,
  last_check            INT DEFAULT NULL,
  type                  TEXT NOT NULL,
  notified_serial       BIGINT DEFAULT NULL,
  account               VARCHAR(40) DEFAULT NULL,
  options               TEXT DEFAULT NULL,
  catalog               VARCHAR(255) DEFAULT NULL,
  CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
);

CREATE UNIQUE INDEX IF NOT EXISTS name_index ON domains(name);
CREATE INDEX IF NOT EXISTS catalog_idx ON domains(catalog);

CREATE TABLE IF NOT EXISTS records (
  id                    BIGSERIAL PRIMARY KEY,
  domain_id             INT DEFAULT NULL,
  name                  VARCHAR(255) DEFAULT NULL,
  type                  VARCHAR(10) DEFAULT NULL,
  content               VARCHAR(65535) DEFAULT NULL,
  ttl                   INT DEFAULT NULL,
  prio                  INT DEFAULT NULL,
  disabled              BOOL DEFAULT 'f',
  ordername             VARCHAR(255),
  auth                  BOOL DEFAULT 't',
  CONSTRAINT domain_exists FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE,
  CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
);

CREATE INDEX IF NOT EXISTS rec_name_index ON records(name);
CREATE INDEX IF NOT EXISTS nametype_index ON records(name,type);
CREATE INDEX IF NOT EXISTS domain_id ON records(domain_id);
CREATE INDEX IF NOT EXISTS ordername ON records(ordername text_pattern_ops);

CREATE TABLE IF NOT EXISTS supermasters (
  ip                    INET NOT NULL,
  nameserver            VARCHAR(255) NOT NULL,
  account               VARCHAR(40) NOT NULL,
  PRIMARY KEY(ip, nameserver)
);

CREATE TABLE IF NOT EXISTS comments (
  id                    SERIAL PRIMARY KEY,
  domain_id             INT NOT NULL,
  name                  VARCHAR(255) NOT NULL,
  type                  VARCHAR(10) NOT NULL,
  modified_at           INT NOT NULL,
  account               VARCHAR(40) DEFAULT NULL,
  comment               TEXT NOT NULL,
  CONSTRAINT domain_exists FOREIGN KEY(domain_id) REFERENCES domains(id) ON DELETE CASCADE,
  CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
);

CREATE INDEX IF NOT EXISTS comments_name_type_idx ON comments(name, type);
CREATE INDEX IF NOT EXISTS comments_order_idx ON comments(domain_id, modified_at);

CREATE TABLE IF NOT EXISTS domainmetadata (
  id                    SERIAL PRIMARY KEY,
  domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
  kind                  VARCHAR(32),
  content               TEXT
);

CREATE INDEX IF NOT EXISTS domainidmetaindex ON domainmetadata(domain_id);

CREATE TABLE IF NOT EXISTS cryptokeys (
  id                    SERIAL PRIMARY KEY,
  domain_id             INT REFERENCES domains(id) ON DELETE CASCADE,
  flags                 INT NOT NULL,
  active                BOOL,
  published             BOOL DEFAULT 't',
  content               TEXT
);

CREATE INDEX IF NOT EXISTS domainidindex ON cryptokeys(domain_id);

CREATE TABLE IF NOT EXISTS tsigkeys (
  id                    SERIAL PRIMARY KEY,
  name                  VARCHAR(255),
  algorithm             VARCHAR(50),
  secret                VARCHAR(255),
  CONSTRAINT c_lowercase_name CHECK (((name)::TEXT = LOWER((name)::TEXT)))
);

CREATE UNIQUE INDEX IF NOT EXISTS namealgoindex ON tsigkeys(name, algorithm);
EOSQL
        fi
        echo "PostgreSQL schema initialized successfully"
    else
        echo "PostgreSQL schema already exists, skipping initialization"
    fi

    # Grant privileges to powerdns user (idempotent)
    echo "Granting privileges to {{ include "powerdns-auth.databaseUsername" . }}..."
    psql <<EOSQL
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO {{ include "powerdns-auth.databaseUsername" . }};
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO {{ include "powerdns-auth.databaseUsername" . }};
EOSQL
    {{- end }}

    echo "Database sync completed successfully"
{{- end }}
