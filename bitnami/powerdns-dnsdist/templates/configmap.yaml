{{/*
Copyright Simon Li
SPDX-License-Identifier: Apache-2.0
*/}}

apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "common.names.fullname" . }}-config
  namespace: {{ include "common.names.namespace" . | quote }}
  labels: {{- include "common.labels.standard" ( dict "customLabels" .Values.commonLabels "context" $ ) | nindent 4 }}
    app.kubernetes.io/component: dnsdist
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  dnsdist.conf: |
    --[[
    ===============================================================================
    DNSdist Configuration
    Generated by Helm Chart v{{ .Chart.Version }}
    ===============================================================================
    --]]

    -- Utility function to check file existence
    function file_exists(name)
        local file = io.open(name, "r")
        if file ~= nil then
            io.close(file)
            return true
        else
            return false
        end
    end

    -- ==========================================================================
    -- Logging Configuration
    -- ==========================================================================
    setVerbose({{ .Values.logging.verbose }})
    setVerboseHealthChecks({{ .Values.logging.verbose }})

    -- ==========================================================================
    -- ACL Configuration
    -- ==========================================================================
    setACL({})
    {{- range .Values.acl.blocked }}
    addACL("!{{ . }}")
    {{- end }}
    {{- range .Values.acl.allowed }}
    addACL("{{ . }}")
    {{- end }}

    -- ==========================================================================
    -- Backend Servers Configuration
    -- ==========================================================================
    {{- if .Values.backends.recursor.enabled }}
    -- Recursor Pool
    {{- range .Values.backends.recursor.servers }}
    newServer({
        address = "{{ .address }}:{{ .port | default 53 }}",
        name = "{{ .name }}",
        pool = "{{ $.Values.backends.recursor.pool }}",
        healthCheckMode = "{{ $.Values.backends.recursor.healthCheck.mode | default "lazy" }}",
        checkInterval = {{ $.Values.backends.recursor.healthCheck.interval | default 5 }},
        {{- if eq ($.Values.backends.recursor.healthCheck.mode | default "lazy") "lazy" }}
        lazyHealthCheckThreshold = {{ $.Values.backends.recursor.healthCheck.lazyThreshold | default 20 }},
        lazyHealthCheckSampleSize = {{ $.Values.backends.recursor.healthCheck.lazySampleSize | default 100 }},
        lazyHealthCheckMinSampleCount = {{ $.Values.backends.recursor.healthCheck.lazyMinSampleCount | default 10 }},
        {{- end }}
        useClientSubnet = {{ $.Values.backends.recursor.useClientSubnet | default true }}
    })
    {{- end }}
    {{- end }}

    {{- if .Values.backends.auth.enabled }}
    -- Authoritative Pool
    {{- range .Values.backends.auth.servers }}
    newServer({
        address = "{{ .address }}:{{ .port | default 53 }}",
        name = "{{ .name }}",
        pool = "{{ $.Values.backends.auth.pool }}",
        healthCheckMode = "{{ $.Values.backends.auth.healthCheck.mode | default "lazy" }}",
        checkInterval = {{ $.Values.backends.auth.healthCheck.interval | default 5 }},
        useClientSubnet = {{ $.Values.backends.auth.useClientSubnet | default true }}
    })
    {{- end }}
    {{- end }}

    {{- if .Values.backends.external.enabled }}
    -- External Upstream Pool
    {{- range .Values.backends.external.servers }}
    newServer({
        address = "{{ .address }}:{{ .port | default 53 }}",
        name = "{{ .name }}",
        pool = "{{ $.Values.backends.external.pool }}",
        healthCheckMode = "{{ $.Values.backends.external.healthCheck.mode | default "lazy" }}",
        checkInterval = {{ $.Values.backends.external.healthCheck.interval | default 10 }}
    })
    {{- end }}
    {{- end }}

    -- ==========================================================================
    -- Cache Configuration
    -- ==========================================================================
    {{- if .Values.cache.enabled }}
    local packetCache = newPacketCache({{ .Values.cache.size }}, {
        maxTTL = {{ .Values.cache.maxTTL }},
        minTTL = {{ .Values.cache.minTTL }},
        {{- if .Values.cache.stale.enabled }}
        temporaryFailureTTL = {{ .Values.cache.stale.ttl }},
        staleTTL = {{ .Values.cache.stale.ttl }},
        {{- end }}
        keepStaleData = {{ .Values.cache.stale.enabled }}
    })
    getPool(""):setCache(packetCache)
    {{- if .Values.backends.recursor.enabled }}
    getPool("{{ .Values.backends.recursor.pool }}"):setCache(packetCache)
    {{- end }}
    {{- if .Values.backends.auth.enabled }}
    getPool("{{ .Values.backends.auth.pool }}"):setCache(packetCache)
    {{- end }}
    {{- if .Values.backends.external.enabled }}
    getPool("{{ .Values.backends.external.pool }}"):setCache(packetCache)
    {{- end }}
    {{- end }}

    -- ==========================================================================
    -- DNS Listeners (Do53)
    -- ==========================================================================
    {{- if .Values.listeners.dns.enabled }}
    setLocal("{{ .Values.listeners.dns.address }}:{{ .Values.listeners.dns.port }}", {
        reusePort = true,
        tcpFastOpenQueueSize = {{ .Values.listeners.dns.tcpFastOpen | default 64 }}
    })
    {{- end }}

    -- ==========================================================================
    -- DNS over TLS (DoT) Listener
    -- ==========================================================================
    {{- if .Values.listeners.dot.enabled }}
    if file_exists("/etc/dnsdist/tls/tls.crt") and file_exists("/etc/dnsdist/tls/tls.key") then
        addTLSLocal("{{ .Values.listeners.dot.address }}:{{ .Values.listeners.dot.port }}",
            "/etc/dnsdist/tls/tls.crt",
            "/etc/dnsdist/tls/tls.key", {
            minTLSVersion = "{{ .Values.listeners.dot.minTLSVersion }}",
            {{- if .Values.listeners.dot.ciphers }}
            ciphers = "{{ .Values.listeners.dot.ciphers }}",
            {{- end }}
            numberOfTicketsKeys = {{ .Values.listeners.dot.numberOfTicketsKeys | default 5 }},
            reusePort = true
        })
        infolog("DoT listener enabled on {{ .Values.listeners.dot.address }}:{{ .Values.listeners.dot.port }}")
    else
        warnlog("DoT: TLS certificates not found, listener disabled")
    end
    {{- end }}

    -- ==========================================================================
    -- DNS over HTTPS (DoH) Listener
    -- ==========================================================================
    {{- if .Values.listeners.doh.enabled }}
    if file_exists("/etc/dnsdist/tls/tls.crt") and file_exists("/etc/dnsdist/tls/tls.key") then
        local dohPaths = { "{{ .Values.listeners.doh.path }}" }
        {{- range .Values.listeners.doh.additionalPaths }}
        table.insert(dohPaths, "{{ . }}")
        {{- end }}

        addDOHLocal("{{ .Values.listeners.doh.address }}:{{ .Values.listeners.doh.port }}",
            "/etc/dnsdist/tls/tls.crt",
            "/etc/dnsdist/tls/tls.key",
            dohPaths, {
            minTLSVersion = "{{ .Values.listeners.doh.minTLSVersion }}",
            reusePort = true,
            keepIncomingHeaders = true
        })

        {{- range .Values.listeners.doh.customResponses }}
        -- Custom response for {{ .path }}
        addDOHLocal("{{ $.Values.listeners.doh.address }}:{{ $.Values.listeners.doh.port }}",
            "/etc/dnsdist/tls/tls.crt",
            "/etc/dnsdist/tls/tls.key",
            { "{{ .path }}" }, {
            customResponseHeaders = { ["Content-Type"] = "{{ .contentType | default "text/plain" }}" }
        })
        {{- end }}

        infolog("DoH listener enabled on {{ .Values.listeners.doh.address }}:{{ .Values.listeners.doh.port }}")
    else
        warnlog("DoH: TLS certificates not found, listener disabled")
    end
    {{- end }}

    -- ==========================================================================
    -- DNS over QUIC (DoQ) Listener
    -- ==========================================================================
    {{- if .Values.listeners.doq.enabled }}
    if file_exists("/etc/dnsdist/tls/tls.crt") and file_exists("/etc/dnsdist/tls/tls.key") then
        addDOQLocal("{{ .Values.listeners.doq.address }}:{{ .Values.listeners.doq.port }}",
            "/etc/dnsdist/tls/tls.crt",
            "/etc/dnsdist/tls/tls.key", {
            idleTimeout = {{ .Values.listeners.doq.idleTimeout }},
            reusePort = true
        })
        infolog("DoQ listener enabled on {{ .Values.listeners.doq.address }}:{{ .Values.listeners.doq.port }}")
    else
        warnlog("DoQ: TLS certificates not found, listener disabled")
    end
    {{- end }}

    -- ==========================================================================
    -- DNS over HTTP/3 (DoH3) Listener
    -- ==========================================================================
    {{- if .Values.listeners.doh3.enabled }}
    if file_exists("/etc/dnsdist/tls/tls.crt") and file_exists("/etc/dnsdist/tls/tls.key") then
        addDOH3Local("{{ .Values.listeners.doh3.address }}:{{ .Values.listeners.doh3.port }}",
            "/etc/dnsdist/tls/tls.crt",
            "/etc/dnsdist/tls/tls.key",
            { "{{ .Values.listeners.doh3.path }}" }, {
            idleTimeout = {{ .Values.listeners.doh3.idleTimeout }},
            reusePort = true
        })
        infolog("DoH3 listener enabled on {{ .Values.listeners.doh3.address }}:{{ .Values.listeners.doh3.port }}")
    else
        warnlog("DoH3: TLS certificates not found, listener disabled")
    end
    {{- end }}

    -- ==========================================================================
    -- DNSCrypt Listener
    -- ==========================================================================
    {{- if .Values.listeners.dnscrypt.enabled }}
    local dnscryptCertPath = "/var/lib/dnsdist/resolver.cert"
    local dnscryptKeyPath = "/var/lib/dnsdist/resolver.key"
    local dnscryptProviderPublic = "/var/lib/dnsdist/providerPublic.key"
    local dnscryptProviderPrivate = "/var/lib/dnsdist/providerPrivate.key"

    -- Generate DNSCrypt keys if not present
    if not file_exists(dnscryptCertPath) or not file_exists(dnscryptKeyPath) then
        infolog("Generating new DNSCrypt keys...")
        generateDNSCryptProviderKeys(dnscryptProviderPublic, dnscryptProviderPrivate)
        generateDNSCryptCertificate(
            dnscryptProviderPrivate,
            dnscryptCertPath,
            dnscryptKeyPath,
            os.date('%Y%m%d', os.time()),
            os.time(),
            os.time() + ({{ .Values.listeners.dnscrypt.certValidity }} * 86400)
        )
        infolog("DNSCrypt keys generated successfully")
    end

    addDNSCryptBind("{{ .Values.listeners.dnscrypt.address }}:{{ .Values.listeners.dnscrypt.port }}",
        "{{ .Values.listeners.dnscrypt.providerName }}",
        dnscryptCertPath,
        dnscryptKeyPath, {
        doTCP = true
    })
    infolog("DNSCrypt listener enabled on {{ .Values.listeners.dnscrypt.address }}:{{ .Values.listeners.dnscrypt.port }}")
    {{- end }}

    -- ==========================================================================
    -- Console Configuration
    -- ==========================================================================
    {{- if .Values.console.enabled }}
    local consoleKey = os.getenv("DNSDIST_CONSOLE_KEY")
    if consoleKey ~= nil and consoleKey ~= "" then
        setKey(consoleKey)
    else
        warnlog("Console key not set - console access may be insecure")
    end
    controlSocket("{{ .Values.console.address }}:{{ .Values.console.port }}")
    setConsoleACL({ {{- range $i, $acl := .Values.console.acl }}{{ if $i }}, {{ end }}"{{ $acl }}"{{- end }} })
    {{- end }}

    -- ==========================================================================
    -- Webserver / API Configuration
    -- ==========================================================================
    {{- if .Values.webserver.enabled }}
    webserver("{{ .Values.webserver.address }}:{{ .Values.webserver.port }}")
    
    -- Read credentials from environment variables (set from Secret)
    local webserverPassword = os.getenv("DNSDIST_WEBSERVER_PASSWORD") or ""
    local apiKey = os.getenv("DNSDIST_API_KEY") or ""
    
    setWebserverConfig({
        password = webserverPassword,
        apiKey = apiKey,
        acl = "{{ .Values.webserver.acl }}",
        statsRequireAuthentication = {{ .Values.webserver.statsRequireAuth }}
    })
    
    if webserverPassword == "" then
        warnlog("Webserver password not set - API access may be insecure")
    end
    {{- end }}

    -- ==========================================================================
    -- Security Rules
    -- ==========================================================================
    {{- if .Values.security.dropChaos }}
    -- Drop CHAOS class queries (version.bind, etc.)
    addAction(QClassRule(DNSClass.CHAOS), DropAction())
    {{- end }}

    {{- if .Values.security.dropAny }}
    -- Drop ANY queries
    addAction(QTypeRule(DNSQType.ANY), DropAction())
    {{- end }}

    -- ==========================================================================
    -- Rate Limiting (Tiered)
    -- ==========================================================================
    {{- if .Values.rateLimit.enabled }}
    -- Tier 1: Delay responses when exceeding {{ .Values.rateLimit.delayThreshold }} QPS per IP
    addAction(MaxQPSIPRule({{ .Values.rateLimit.delayThreshold }}, {{ .Values.rateLimit.ipv4PrefixLength }}, {{ .Values.rateLimit.ipv6PrefixLength }}),
        DelayAction({{ .Values.rateLimit.delayMs }}))

    -- Tier 2: Drop queries when exceeding {{ .Values.rateLimit.dropThreshold }} QPS per IP
    addAction(MaxQPSIPRule({{ .Values.rateLimit.dropThreshold }}, {{ .Values.rateLimit.ipv4PrefixLength }}, {{ .Values.rateLimit.ipv6PrefixLength }}),
        DropAction())
    {{- end }}

    -- ==========================================================================
    -- Query Logging
    -- ==========================================================================
    {{- if .Values.logging.queries }}
    addAction(AllRule(), LogAction("/dev/stdout", false, false, false))
    {{- end }}
    {{- if .Values.logging.responses }}
    addResponseAction(AllRule(), LogResponseAction("/dev/stdout", false, false, false, false))
    {{- end }}

    -- ==========================================================================
    -- Blocklist (loaded via conf.d directory)
    -- ==========================================================================
    {{- if .Values.blocklist.enabled }}
    -- Blocklist configuration is loaded from /etc/dnsdist/blocklist/blocklist.conf
    -- which is included via the conf.d directory mechanism below
    {{- end }}

    -- ==========================================================================
    -- Routing Rules
    -- ==========================================================================
    {{- range .Values.routing.rules }}
    -- Rule: {{ .name }}
    {{- if eq .match.type "suffix" }}
    addAction(SuffixMatchNodeRule(newSuffixMatchNode():add(newDNSName("{{ .match.value }}"))), PoolAction("{{ .action.pool }}"))
    {{- else if eq .match.type "qname" }}
    addAction(QNameRule("{{ .match.value }}"), PoolAction("{{ .action.pool }}"))
    {{- else if eq .match.type "qtype" }}
    addAction(QTypeRule(DNSQType.{{ .match.value }}), PoolAction("{{ .action.pool }}"))
    {{- else if eq .match.type "netmask" }}
    addAction(NetmaskGroupRule(newNMG({"{{ .match.value }}"})), PoolAction("{{ .action.pool }}"))
    {{- end }}
    {{- end }}

    -- Default routing: send to {{ .Values.routing.defaultPool }}
    addAction(AllRule(), PoolAction("{{ .Values.routing.defaultPool }}"))

    -- ==========================================================================
    -- Include Additional Configuration Files
    -- ==========================================================================
    includeDirectory("/etc/dnsdist/conf.d")

    -- ==========================================================================
    -- Extra Configuration
    -- ==========================================================================
    {{ .Values.extraConfig | default "" | nindent 4 }}

    -- ==========================================================================
    -- Startup Complete
    -- ==========================================================================
    infolog("DNSdist configuration loaded successfully")
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "common.names.fullname" . }}-config-extra
  namespace: {{ include "common.names.namespace" . | quote }}
  labels: {{- include "common.labels.standard" ( dict "customLabels" .Values.commonLabels "context" $ ) | nindent 4 }}
    app.kubernetes.io/component: dnsdist
  {{- if .Values.commonAnnotations }}
  annotations: {{- include "common.tplvalues.render" ( dict "value" .Values.commonAnnotations "context" $ ) | nindent 4 }}
  {{- end }}
data:
  {{- range $key, $value := .Values.extraConfigFiles }}
  {{ $key }}: |
    {{- $value | nindent 4 }}
  {{- end }}
  _placeholder: "# Extra config files"
